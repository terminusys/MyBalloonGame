<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¢¦å¹»çƒ­æ°”çƒé£è¡Œ</title>
    <!-- å¼•å…¥ç°ä»£å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 40%, #7fa3d1 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;  /* é˜²æ­¢æ»šåŠ¨ */
        }
        #game-container {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            max-width: 100%;   /* å“åº”å¼ï¼šä¸è¶…è¿‡å±å¹•å®½åº¦ */
            max-height: 100vh; /* å“åº”å¼ï¼šä¸è¶…è¿‡å±å¹•é«˜åº¦ */
        }
        #game-container canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
        }
        
        /* åå­—è¾“å…¥å¼¹çª—æ ·å¼ */
        #name-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        #name-modal.hidden {
            display: none;
        }
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: modalFadeIn 0.3s ease-out;
        }
        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .modal-content h2 {
            color: #fff;
            margin: 0 0 10px 0;
            font-size: 28px;
            font-weight: 700;
        }
        .modal-content p {
            color: rgba(255, 255, 255, 0.9);
            margin: 0 0 25px 0;
            font-size: 16px;
        }
        #player-name-input {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            text-align: center;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            font-weight: 600;
            outline: none;
            transition: all 0.3s;
        }
        #player-name-input:focus {
            background: #fff;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }
        #player-name-input::placeholder {
            color: #999;
            font-weight: 400;
        }
        #start-game-btn {
            margin-top: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }
        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }
        #start-game-btn:active {
            transform: translateY(0);
        }
        .emoji-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        /* æ›´æ”¹åå­—æŒ‰é’®æ ·å¼ */
        #change-name-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
            z-index: 999;
            opacity: 1;
            pointer-events: auto;
        }
        #change-name-btn.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #change-name-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        #change-name-btn:active {
            transform: translateY(0);
        }
        
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            #change-name-btn {
                font-size: 12px;
                padding: 8px 15px;
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- æ›´æ”¹åå­—æŒ‰é’® -->
    <button id="change-name-btn">ğŸ‘¤ æ›´æ”¹åå­—</button>

    <!-- åå­—è¾“å…¥å¼¹çª— -->
    <div id="name-modal">
        <div class="modal-content">
            <div class="emoji-icon">ğŸˆ</div>
            <h2>æ¬¢è¿æ¥åˆ°çƒ­æ°”çƒä¸–ç•Œ</h2>
            <p>è¯·è¾“å…¥ä½ çš„åå­—å¼€å§‹æ¸¸æˆ</p>
            <input 
                type="text" 
                id="player-name-input" 
                placeholder="ä¾‹å¦‚ï¼šå¼ ä¸‰ã€æå››..." 
                maxlength="10"
                autocomplete="off"
            />
            <button id="start-game-btn">ğŸš€ å¼€å§‹é£è¡Œ</button>
        </div>
    </div>

    <!-- æ¸¸æˆå®¹å™¨ -->
    <div id="game-container"></div>

    <!-- å¼•å…¥ Phaser.js åº“ (ä»CDNåŠ è½½) -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- å¼•å…¥ Supabase å®¢æˆ·ç«¯åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // ==================== ç©å®¶åå­—ç®¡ç† ====================
        let playerName = '';
        let gameStarted = false;
        let playerNameTextObject = null;  // ä¿å­˜ç©å®¶åå­—æ–‡æœ¬å¯¹è±¡çš„å¼•ç”¨
        let gameScene = null;  // ä¿å­˜æ¸¸æˆåœºæ™¯å¯¹è±¡
        
        // ä» localStorage è¯»å–ä¿å­˜çš„åå­—
        const savedName = localStorage.getItem('balloonPlayerName');
        if (savedName) {
            playerName = savedName;
            document.getElementById('name-modal').classList.add('hidden');
            document.getElementById('change-name-btn').classList.remove('hidden');
            gameStarted = true;
        } else {
            document.getElementById('change-name-btn').classList.add('hidden');
        }
        
        // å¤„ç†å¼€å§‹æ¸¸æˆæŒ‰é’®
        document.getElementById('start-game-btn').addEventListener('click', startGame);
        
        // å¤„ç†æ›´æ”¹åå­—æŒ‰é’®
        document.getElementById('change-name-btn').addEventListener('click', function() {
            document.getElementById('name-modal').classList.remove('hidden');
            document.getElementById('player-name-input').value = playerName;
            document.getElementById('player-name-input').focus();
            document.getElementById('player-name-input').select();
        });
        
        // å¤„ç†å›è½¦é”®
        document.getElementById('player-name-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                startGame();
            }
        });
        
        function startGame() {
            const input = document.getElementById('player-name-input').value.trim();
            
            console.log('ğŸ¯ startGame è¢«è°ƒç”¨ï¼Œè¾“å…¥å€¼:', input);
            
            if (!input) {
                alert('è¯·è¾“å…¥ä½ çš„åå­—ï¼');
                return;
            }
            
            if (input.length < 2) {
                alert('åå­—è‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦ï¼');
                return;
            }
            
            const isNameChanged = (playerName && playerName !== input);
            playerName = input;
            localStorage.setItem('balloonPlayerName', playerName);
            document.getElementById('name-modal').classList.add('hidden');
            document.getElementById('change-name-btn').classList.remove('hidden');
            
            console.log('âœ… åå­—å·²è®¾ç½®:', playerName);
            console.log('ğŸ“ gameScene çŠ¶æ€:', gameScene ? 'å·²å­˜åœ¨' : 'æœªåˆ›å»º');
            
            // å¦‚æœæ˜¯æ›´æ”¹åå­—ï¼Œæ›´æ–°æ˜¾ç¤º
            if (isNameChanged && playerNameTextObject) {
                playerNameTextObject.setText(playerName);
                console.log('âœï¸ åå­—å·²æ›´æ”¹ä¸º:', playerName);
                // å‘é€æ›´æ–°åˆ° Supabase
                sendPositionUpdate(balloon.x, balloon.y);
                return;  // æ›´æ”¹åå­—çš„æƒ…å†µï¼Œç›´æ¥è¿”å›
            }
            
            // å¦‚æœæ˜¯é¦–æ¬¡å¯åŠ¨æ¸¸æˆ
            if (!gameStarted) {
                gameStarted = true;
                console.log('ğŸˆ æ¸¸æˆé¦–æ¬¡å¯åŠ¨ï¼Œç©å®¶:', playerName);
                
                // å¦‚æœæ¸¸æˆåœºæ™¯å·²ç»åˆ›å»ºï¼Œç«‹å³åˆå§‹åŒ–
                if (gameScene) {
                    console.log('ğŸš€ åœºæ™¯å·²å­˜åœ¨ï¼Œç«‹å³åˆå§‹åŒ–æ¸¸æˆ...');
                    try {
                        initializeGame.call(gameScene);
                        console.log('âœ… æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼');
                    } catch (error) {
                        console.error('âŒ æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
                    }
                } else {
                    console.log('â³ åœºæ™¯æœªåˆ›å»ºï¼Œç­‰å¾… Phaser åœºæ™¯åˆå§‹åŒ–...');
                }
            }
        }
        
        // ==================== Supabase é…ç½® ====================
        const SUPABASE_URL = 'https://ksctfambipodjbrtjaby.supabase.co';
        // âš ï¸ æ³¨æ„ï¼šè¯·å°†ä¸‹é¢çš„ anon key æ›¿æ¢ä¸ºä½ çš„çœŸå® Supabase anon key
        // çœŸå®çš„ anon key åº”è¯¥æ˜¯ä»¥ "eyJ" å¼€å¤´çš„é•¿å­—ç¬¦ä¸²ï¼ˆJWT tokenï¼‰
        // ä½ å¯ä»¥åœ¨ Supabase Dashboard > Settings > API ä¸­æ‰¾åˆ°
                const SUPABASE_ANON_KEY = 'sb_publishable_8MsjbT3RenOKGNyMafKv-Q_b8MNN7Qn';

        // ç”Ÿæˆå½“å‰ç©å®¶çš„å”¯ä¸€ID
        const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        
        // ç©å®¶åå­—å°†åœ¨ç”¨æˆ·è¾“å…¥åè®¾ç½®
        console.log('ğŸˆ ç©å®¶ ID:', playerId);
        
        // åˆ›å»º Supabase å®¢æˆ·ç«¯ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼Œé¿å…é‡å¤å£°æ˜ï¼‰
        let supabaseClient = null;
        try {
            if (typeof window.supabase !== 'undefined') {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('âœ… Supabase å®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ');
            } else {
                console.error('âŒ Supabase åº“æœªåŠ è½½ï¼');
            }
        } catch (error) {
            console.error('âŒ Supabase åˆå§‹åŒ–å¤±è´¥:', error);
        }

        // ==================== Phaser æ¸¸æˆé…ç½® ====================
        const config = {
            type: Phaser.AUTO,              // è‡ªåŠ¨é€‰æ‹©æ¸²æŸ“å™¨ (WebGL æˆ– Canvas)
            width: 800,                     // æ¸¸æˆç”»å¸ƒå®½åº¦
            height: 600,                    // æ¸¸æˆç”»å¸ƒé«˜åº¦
            parent: 'game-container',       // å°†æ¸¸æˆæŒ‚è½½åˆ°è¿™ä¸ªDOMå…ƒç´ 
            backgroundColor: '#87CEEB',     // èƒŒæ™¯é¢œè‰² (å¤©è“è‰²)
            scale: {
                mode: Phaser.Scale.FIT,     // è‡ªé€‚åº”ç¼©æ”¾æ¨¡å¼ï¼šä¿æŒå®½é«˜æ¯”å¹¶å¡«å……å±å¹•
                autoCenter: Phaser.Scale.CENTER_BOTH,  // å±…ä¸­æ˜¾ç¤º
                width: 800,
                height: 600
            },
            scene: {
                create: create,             // åˆ›å»ºåœºæ™¯æ—¶è°ƒç”¨
                update: update              // æ¯å¸§æ›´æ–°æ—¶è°ƒç”¨
            }
        };

        // åˆ›å»º Phaser æ¸¸æˆå®ä¾‹
        const game = new Phaser.Game(config);

        // æ¸¸æˆå¯¹è±¡å˜é‡
        let balloon;                        // æ°”çƒå®¹å™¨å¯¹è±¡
        let balloonBody;                    // æ°”çƒæœ¬ä½“å›¾å½¢
        let basket;                         // æ°”çƒç¯®å­
        let playerNameText;                 // ç©å®¶åå­—æ–‡æœ¬
        let targetX = 400;                  // æ°”çƒç›®æ ‡Xåæ ‡
        let targetY = 300;                  // æ°”çƒç›®æ ‡Yåæ ‡
        let breatheOffset = 0;              // å‘¼å¸åŠ¨ç”»çš„åç§»é‡
        let clouds = [];                    // äº‘æœµæ•°ç»„
        let previousX = 400;                // è®°å½•æ°”çƒä¸Šä¸€å¸§çš„Xä½ç½®ï¼Œç”¨äºè®¡ç®—å€¾æ–œæ–¹å‘
        let otherPlayers = {};              // å­˜å‚¨å…¶ä»–ç©å®¶çš„æ°”çƒå¯¹è±¡
        let lastUpdateTime = 0;             // ä¸Šæ¬¡å‘é€ä½ç½®æ›´æ–°çš„æ—¶é—´
        const UPDATE_INTERVAL = 100;        // ä½ç½®æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
        
        // æ¸¸æˆå…ƒç´ 
        let coins = [];                     // é‡‘å¸æ•°ç»„
        let obstacles = [];                 // éšœç¢ç‰©æ•°ç»„
        let score = 0;                      // å½“å‰åˆ†æ•°
        let scoreText;                      // åˆ†æ•°æ˜¾ç¤ºæ–‡æœ¬

        // ==================== ç»˜åˆ¶åƒç´ é£çƒ­æ°”çƒå‡½æ•° ====================
        function drawStripedBalloon(graphics) {
            // æ¸…ç©ºä¹‹å‰çš„ç»˜åˆ¶
            graphics.clear();
            
            // çƒ­æ°”çƒå‚æ•°
            const balloonWidth = 50;
            const balloonHeight = 65;
            const stripeCount = 8;  // æ¡çº¹æ•°é‡
            
            // ---------- ç»˜åˆ¶çº¢ç™½ç›¸é—´æ¡çº¹çš„çƒ­æ°”çƒçƒä½“ ----------
            for (let i = 0; i < stripeCount; i++) {
                // è®¡ç®—å½“å‰æ¡çº¹çš„è§’åº¦èŒƒå›´
                const startAngle = (i * Math.PI) / stripeCount - Math.PI / 2;
                const endAngle = ((i + 1) * Math.PI) / stripeCount - Math.PI / 2;
                
                // äº¤æ›¿ä½¿ç”¨çº¢è‰²å’Œç™½è‰²
                const color = i % 2 === 0 ? 0xE63946 : 0xF1FAEE;
                graphics.fillStyle(color, 1);
                
                // ç»˜åˆ¶æ‰‡å½¢æ¡çº¹
                graphics.beginPath();
                graphics.moveTo(0, -10);  // ä»é¡¶éƒ¨ä¸­å¿ƒå¼€å§‹
                
                // ç»˜åˆ¶æ¤­åœ†å¼§çº¿ï¼ˆçƒ­æ°”çƒå½¢çŠ¶ï¼‰
                for (let angle = startAngle; angle <= endAngle; angle += 0.1) {
                    const x = Math.cos(angle) * balloonWidth;
                    const y = Math.sin(angle) * balloonHeight - 10;
                    graphics.lineTo(x, y);
                }
                
                graphics.closePath();
                graphics.fillPath();
            }
            
            // ---------- ç»˜åˆ¶çƒ­æ°”çƒåº•éƒ¨ ----------
            graphics.fillStyle(0x457B9D, 1);  // æ·±è“è‰²åº•åº§
            graphics.fillRect(-balloonWidth, balloonHeight - 10, balloonWidth * 2, 8);
            
            // ---------- ç»˜åˆ¶è¿æ¥ç»³ ----------
            graphics.lineStyle(2, 0x8B4513, 1);  // æ£•è‰²ç»³å­
            
            // å·¦ä¾§ç»³å­
            graphics.beginPath();
            graphics.moveTo(-30, balloonHeight);
            graphics.lineTo(-15, balloonHeight + 25);
            graphics.strokePath();
            
            // å³ä¾§ç»³å­
            graphics.beginPath();
            graphics.moveTo(30, balloonHeight);
            graphics.lineTo(15, balloonHeight + 25);
            graphics.strokePath();
        }
        
        // ==================== ç»˜åˆ¶ç¯®å­å‡½æ•° ====================
        function drawBasket(graphics) {
            graphics.clear();
            
            // ---------- ç»˜åˆ¶ç¯®å­ä¸»ä½“ï¼ˆåƒç´ é£æ ¼ï¼‰----------
            graphics.fillStyle(0x8B4513, 1);  // æ£•è‰²
            graphics.fillRect(-15, 0, 30, 20);
            
            // ç»˜åˆ¶ç¯®å­çº¹ç†ï¼ˆæ¨ªå‘æ¡çº¹ï¼‰
            graphics.lineStyle(2, 0x654321, 1);
            for (let i = 5; i < 20; i += 5) {
                graphics.beginPath();
                graphics.moveTo(-15, i);
                graphics.lineTo(15, i);
                graphics.strokePath();
            }
            
            // ç»˜åˆ¶ç¯®å­è¾¹æ¡†
            graphics.lineStyle(2, 0x5A3A1A, 1);
            graphics.strokeRect(-15, 0, 30, 20);
        }

        // ==================== åˆ›å»ºé‡‘å¸å‡½æ•° ====================
        function createCoin(scene, x, y) {
            const coin = scene.add.graphics();
            coin.x = x;
            coin.y = y;
            
            // ç»˜åˆ¶é‡‘å¸ï¼ˆåœ†å½¢ï¼Œé‡‘é»„è‰²ï¼‰
            coin.fillStyle(0xFFD700, 1);  // é‡‘è‰²
            coin.fillCircle(0, 0, 15);
            
            // æ·»åŠ å†…åœˆ
            coin.fillStyle(0xFFA500, 1);  // æ©™è‰²
            coin.fillCircle(0, 0, 10);
            
            // æ·»åŠ å…‰æ³½
            coin.fillStyle(0xFFFFAA, 1);
            coin.fillCircle(-4, -4, 4);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»
            scene.tweens.add({
                targets: coin,
                scaleX: 0.2,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            // æ·»åŠ ä¸Šä¸‹æµ®åŠ¨
            scene.tweens.add({
                targets: coin,
                y: y + 10,
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            return {
                graphic: coin,
                x: x,
                y: y,
                radius: 15,
                collected: false
            };
        }
        
        // ==================== åˆ›å»ºéšœç¢ç‰©å‡½æ•° ====================
        function createObstacle(scene, x, y, type) {
            const obstacle = scene.add.graphics();
            obstacle.x = x;
            obstacle.y = y;
            
            if (type === 'bird') {
                // ç»˜åˆ¶å°é¸Ÿéšœç¢ç‰©
                obstacle.fillStyle(0x8B4513, 1);  // æ£•è‰²
                obstacle.fillEllipse(0, 0, 30, 20);
                
                obstacle.fillStyle(0xFFFFFF, 1);  // ç™½è‰²ç¿…è†€
                obstacle.fillEllipse(-15, 0, 15, 8);
                obstacle.fillEllipse(15, 0, 15, 8);
                
                obstacle.fillStyle(0xFF6B6B, 1);  // çº¢è‰²
                obstacle.fillTriangle(-8, 0, -12, 2, -8, 4);
                
                // é£è¡ŒåŠ¨ç”»
                scene.tweens.add({
                    targets: obstacle,
                    y: y + 20,
                    duration: 1500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            } else if (type === 'cloud') {
                // ç»˜åˆ¶é›·äº‘éšœç¢ç‰©
                obstacle.fillStyle(0x666666, 1);  // ç°è‰²äº‘
                obstacle.fillCircle(0, 0, 25);
                obstacle.fillCircle(-15, 5, 20);
                obstacle.fillCircle(15, 5, 20);
                
                // é—ªç”µæ•ˆæœ
                obstacle.lineStyle(3, 0xFFFF00, 1);
                obstacle.beginPath();
                obstacle.moveTo(0, 20);
                obstacle.lineTo(-5, 30);
                obstacle.lineTo(0, 30);
                obstacle.lineTo(-5, 40);
                obstacle.strokePath();
            }
            
            return {
                graphic: obstacle,
                x: x,
                y: y,
                width: 50,
                height: 40,
                type: type
            };
        }
        
        // ==================== ç”Ÿæˆæ¸¸æˆå…ƒç´ å‡½æ•° ====================
        function spawnGameElements(scene) {
            // éšæœºç”Ÿæˆé‡‘å¸
            if (Math.random() < 0.02) {  // 2% æ¦‚ç‡æ¯å¸§
                const x = Math.random() * config.width;
                const y = Math.random() * config.height;
                const coin = createCoin(scene, x, y);
                coins.push(coin);
            }
            
            // éšæœºç”Ÿæˆéšœç¢ç‰©
            if (Math.random() < 0.01 && obstacles.length < 5) {  // 1% æ¦‚ç‡ï¼Œæœ€å¤š5ä¸ª
                const x = Math.random() * config.width;
                const y = Math.random() * (config.height * 0.7) + 50;
                const type = Math.random() > 0.5 ? 'bird' : 'cloud';
                const obstacle = createObstacle(scene, x, y, type);
                obstacles.push(obstacle);
            }
        }
        
        // ==================== ç¢°æ’æ£€æµ‹å‡½æ•° ====================
        function checkCollisions() {
            if (!balloon) return;
            
            // æ£€æµ‹é‡‘å¸ç¢°æ’
            coins.forEach((coin, index) => {
                if (coin.collected) return;
                
                const distance = Phaser.Math.Distance.Between(
                    balloon.x, balloon.y,
                    coin.x, coin.graphic.y
                );
                
                if (distance < 40) {  // ç¢°æ’åŠå¾„
                    // æ”¶é›†é‡‘å¸
                    coin.collected = true;
                    score += 10;
                    updateScore();
                    
                    // é‡‘å¸æ¶ˆå¤±åŠ¨ç”»
                    gameScene.tweens.add({
                        targets: coin.graphic,
                        alpha: 0,
                        scale: 2,
                        duration: 300,
                        onComplete: () => {
                            coin.graphic.destroy();
                            coins.splice(index, 1);
                        }
                    });
                    
                    // æ’­æ”¾éŸ³æ•ˆï¼ˆæ–‡å­—æç¤ºï¼‰
                    showFloatingText(gameScene, balloon.x, balloon.y - 50, '+10', 0x00FF00);
                }
            });
            
            // æ£€æµ‹éšœç¢ç‰©ç¢°æ’
            obstacles.forEach(obstacle => {
                const distance = Phaser.Math.Distance.Between(
                    balloon.x, balloon.y,
                    obstacle.x, obstacle.graphic.y
                );
                
                if (distance < 60) {  // ç¢°æ’åŠå¾„
                    // å‡é€Ÿæ•ˆæœ
                    score = Math.max(0, score - 5);
                    updateScore();
                    
                    // éœ‡åŠ¨æ•ˆæœ
                    gameScene.cameras.main.shake(200, 0.01);
                    
                    showFloatingText(gameScene, balloon.x, balloon.y - 50, '-5', 0xFF0000);
                    
                    // éšœç¢ç‰©æ¶ˆå¤±
                    obstacle.graphic.destroy();
                    obstacles.splice(obstacles.indexOf(obstacle), 1);
                }
            });
        }
        
        // ==================== æ˜¾ç¤ºæµ®åŠ¨æ–‡å­—å‡½æ•° ====================
        function showFloatingText(scene, x, y, text, color) {
            const floatText = scene.add.text(x, y, text, {
                fontSize: '24px',
                fontFamily: 'Inter, sans-serif',
                color: '#' + color.toString(16).padStart(6, '0'),
                fontStyle: 'bold'
            });
            floatText.setOrigin(0.5, 0.5);
            
            scene.tweens.add({
                targets: floatText,
                y: y - 50,
                alpha: 0,
                duration: 1000,
                onComplete: () => floatText.destroy()
            });
        }
        
        // ==================== æ›´æ–°åˆ†æ•°æ˜¾ç¤º ====================
        function updateScore() {
            if (scoreText) {
                scoreText.setText('ğŸª™ ' + score);
            }
        }

        // ==================== åˆ›å»ºç™½äº‘å‡½æ•° ====================
        function createCloud(scene, x, y, scale) {
            const cloud = scene.add.graphics();
            cloud.x = x;
            cloud.y = y;
            cloud.setScale(scale);
            
            // ç»˜åˆ¶äº‘æœµï¼ˆå¤šä¸ªåœ†å½¢ç»„åˆï¼‰
            cloud.fillStyle(0xFFFFFF, 0.8);  // ç™½è‰²ï¼Œ80%ä¸é€æ˜åº¦
            cloud.fillCircle(0, 0, 20);
            cloud.fillCircle(-15, 5, 15);
            cloud.fillCircle(15, 5, 15);
            cloud.fillCircle(-8, -8, 12);
            cloud.fillCircle(8, -8, 12);
            
            return cloud;
        }

        // ==================== åˆ›å»ºå…¶ä»–ç©å®¶æ°”çƒå‡½æ•° ====================
        function createOtherPlayerBalloon(scene, data) {
            // åˆ›å»ºå®¹å™¨
            const container = scene.add.container(data.x, data.y);
            
            // åˆ›å»ºæ°”çƒæœ¬ä½“
            const body = scene.add.graphics();
            drawStripedBalloon(body);
            container.add(body);
            
            // åˆ›å»ºç¯®å­
            const playerBasket = scene.add.graphics();
            playerBasket.y = 90;
            drawBasket(playerBasket);
            container.add(playerBasket);
            
            // åˆ›å»ºç©å®¶åå­—æ ‡ç­¾
            const nameText = scene.add.text(
                0, -90,
                data.name,
                {
                    fontSize: '14px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#FFFFFF',
                    backgroundColor: '#00000099',
                    padding: { x: 8, y: 4 },
                    fontStyle: '600'
                }
            );
            nameText.setOrigin(0.5, 0.5);
            container.add(nameText);
            
            // è®¾ç½®é€æ˜åº¦ï¼ˆå…¶ä»–ç©å®¶ç¨å¾®é€æ˜ä¸€ç‚¹ï¼‰
            container.setAlpha(0.8);
            
            return {
                container: container,
                targetX: data.x,
                targetY: data.y,
                nameText: nameText
            };
        }

        // ==================== åˆ›å»ºåœºæ™¯å‡½æ•° ====================
        function create() {
            // ä¿å­˜åœºæ™¯å¯¹è±¡å¼•ç”¨
            gameScene = this;
            
            console.log('ğŸ® Phaser åœºæ™¯åˆ›å»ºå®Œæˆ');
            console.log('ğŸ“ gameStarted çŠ¶æ€:', gameStarted);
            console.log('ğŸ‘¤ playerName:', playerName);
            
            // å¦‚æœæ¸¸æˆè¿˜æœªå¼€å§‹ï¼ˆç”¨æˆ·æœªè¾“å…¥åå­—ï¼‰ï¼Œç­‰å¾…
            if (!gameStarted) {
                console.log('â³ ç­‰å¾…ç©å®¶è¾“å…¥åå­—...');
                // ä½¿ç”¨äº‹ä»¶ç›‘å¬ç­‰å¾…æ¸¸æˆå¼€å§‹
                return;
            }
            
            // å¦‚æœå·²ç»æœ‰åå­—ï¼Œç›´æ¥åˆå§‹åŒ–
            console.log('ğŸš€ ç«‹å³å¼€å§‹åˆå§‹åŒ–æ¸¸æˆ...');
            initializeGame.call(this);
        }
        
        // ==================== åˆå§‹åŒ–æ¸¸æˆå‡½æ•° ====================
        function initializeGame() {
            // è·å–å½“å‰åœºæ™¯å¯¹è±¡
            const scene = this;

            // ---------- åˆ›å»ºæ¸å˜èƒŒæ™¯å±‚ ----------
            const bgGraphics = scene.add.graphics();
            // å¤©ç©ºæ¸å˜ï¼ˆä»æ·±è“åˆ°æµ…è“ï¼‰
            bgGraphics.fillGradientStyle(0x5B9BD5, 0x5B9BD5, 0x87CEEB, 0x87CEEB, 1);
            bgGraphics.fillRect(0, 0, config.width, config.height);

            // ---------- åˆ›å»ºéšæœºæ¼‚æµ®çš„ç™½äº‘ ----------
            const cloudCount = 6;  // äº‘æœµæ•°é‡
            for (let i = 0; i < cloudCount; i++) {
                const x = Math.random() * config.width;
                const y = Math.random() * (config.height * 0.4) + 50;  // äº‘æœµåœ¨ä¸ŠåŠéƒ¨åˆ†
                const scale = Math.random() * 0.5 + 0.5;  // éšæœºç¼©æ”¾ 0.5-1.0
                const speed = Math.random() * 0.3 + 0.1;  // éšæœºé€Ÿåº¦
                
                const cloud = createCloud(scene, x, y, scale);
                clouds.push({ graphic: cloud, speed: speed });
            }

            // ---------- åˆ›å»ºåƒç´ é£çƒ­æ°”çƒ ----------
            // åˆ›å»ºå®¹å™¨æ¥åŒ…å«æ°”çƒæ‰€æœ‰éƒ¨åˆ†
            balloon = scene.add.container(config.width / 2, config.height / 2);
            
            // åˆ›å»ºæ°”çƒæœ¬ä½“
            balloonBody = scene.add.graphics();
            drawStripedBalloon(balloonBody);
            balloon.add(balloonBody);
            
            // åˆ›å»ºç¯®å­ï¼ˆä½ç½®åœ¨æ°”çƒä¸‹æ–¹ï¼‰
            basket = scene.add.graphics();
            basket.y = 90;  // ç¯®å­åœ¨æ°”çƒä¸‹æ–¹90åƒç´ 
            drawBasket(basket);
            balloon.add(basket);
            
            // åˆ›å»ºç©å®¶åå­—æ ‡ç­¾ï¼ˆåœ¨æ°”çƒä¸Šæ–¹ï¼‰
            playerNameText = scene.add.text(
                0, -90,
                playerName,
                {
                    fontSize: '16px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#FFD700',  // é‡‘è‰²
                    backgroundColor: '#000000CC',
                    padding: { x: 10, y: 5 },
                    fontStyle: 'bold'
                }
            );
            playerNameText.setOrigin(0.5, 0.5);
            balloon.add(playerNameText);
            
            // ä¿å­˜åˆ°å…¨å±€å˜é‡ï¼Œç”¨äºæ›´æ”¹åå­—æ—¶æ›´æ–°
            playerNameTextObject = playerNameText;

            // ---------- åˆ›å»ºåˆ†æ•°æ˜¾ç¤º ----------
            scoreText = scene.add.text(
                20, 20,
                'ğŸª™ 0',
                {
                    fontSize: '24px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#FFD700',
                    backgroundColor: '#00000099',
                    padding: { x: 15, y: 8 },
                    fontStyle: 'bold'
                }
            );
            scoreText.setScrollFactor(0);
            scoreText.setDepth(1000);

            // è®¾ç½®åˆå§‹ç›®æ ‡ä½ç½®ä¸ºå½“å‰ä½ç½®
            targetX = balloon.x;
            targetY = balloon.y;
            previousX = balloon.x;

            // ---------- æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬ ----------
            scene.input.on('pointerdown', function(pointer) {
                // å½“ç©å®¶ç‚¹å‡»å±å¹•æ—¶ï¼Œæ›´æ–°ç›®æ ‡ä½ç½®
                targetX = pointer.x;
                targetY = pointer.y;
                
                // å‘é€ä½ç½®æ›´æ–°åˆ° Supabase
                sendPositionUpdate(pointer.x, pointer.y);
                
                // ç‚¹å‡»ä½ç½®åé¦ˆæ•ˆæœï¼ˆä¼˜åŒ–ç‰ˆï¼‰
                const marker = scene.add.circle(pointer.x, pointer.y, 8, 0xFFFFFF, 0.6);
                const outerRing = scene.add.circle(pointer.x, pointer.y, 8, 0xFFFFFF, 0);
                outerRing.setStrokeStyle(2, 0xFFFFFF, 0.8);
                
                scene.tweens.add({
                    targets: marker,
                    alpha: 0,
                    scale: 1.5,
                    duration: 400,
                    ease: 'Power2',
                    onComplete: () => marker.destroy()
                });
                
                scene.tweens.add({
                    targets: outerRing,
                    alpha: 0,
                    scale: 3,
                    duration: 600,
                    ease: 'Power2',
                    onComplete: () => outerRing.destroy()
                });
            });

            // ---------- åˆ›å»ºé‡‘é—ªé—ªå¹¿å‘Šä½å¡ç‰‡ ----------
            // å¤–å±‚å…‰æ™•å®¹å™¨
            const adGlowOuter = scene.add.graphics();
            const adGlowMiddle = scene.add.graphics();
            
            // ç»˜åˆ¶å¤šå±‚é‡‘è‰²å…‰æ™•
            adGlowOuter.lineStyle(4, 0xFFD700, 0.3);
            adGlowOuter.strokeRoundedRect(config.width - 245, 10, 230, 70, 15);
            
            adGlowMiddle.lineStyle(3, 0xFFA500, 0.5);
            adGlowMiddle.strokeRoundedRect(config.width - 243, 12, 226, 66, 14);
            
            // åŠé€æ˜èƒŒæ™¯
            const adBg = scene.add.graphics();
            adBg.fillStyle(0xFFFFFF, 0.15);  // ç™½è‰²åŠé€æ˜
            adBg.fillRoundedRect(config.width - 240, 15, 220, 60, 12);
            
            // é‡‘è‰²è¾¹æ¡†
            adBg.lineStyle(2, 0xFFD700, 0.8);
            adBg.strokeRoundedRect(config.width - 240, 15, 220, 60, 12);
            
            // å†…éƒ¨é‡‘é»„è‰²èƒŒæ™¯
            const adInner = scene.add.graphics();
            adInner.fillStyle(0xFFC107, 0.9);  // é‡‘é»„è‰²ï¼Œ90%ä¸é€æ˜åº¦
            adInner.fillRoundedRect(config.width - 235, 20, 210, 50, 10);

            // å¹¿å‘Šä½æ–‡å­—ï¼ˆç°ä»£å­—ä½“ï¼‰
            const adText = scene.add.text(
                config.width - 130,
                42,
                'ğŸ’ å¹¿å‘Šä½æ‹›ç§Ÿ',
                {
                    fontSize: '18px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#1A1A1A',
                    fontStyle: 'bold'
                }
            );
            adText.setOrigin(0.5, 0.5);
            
            // ä»·æ ¼æ–‡å­—
            const priceText = scene.add.text(
                config.width - 130,
                60,
                '$5,000',
                {
                    fontSize: '16px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#D4AF37',  // é‡‘è‰²
                    fontStyle: 'bold'
                }
            );
            priceText.setOrigin(0.5, 0.5);

            // æ·»åŠ é—ªçƒåŠ¨ç”»åˆ°å¹¿å‘Šä½ï¼ˆé‡‘è‰²å…‰æ™•æ•ˆæœï¼‰
            scene.tweens.add({
                targets: [adGlowOuter],
                alpha: 0.1,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            scene.tweens.add({
                targets: [adGlowMiddle],
                alpha: 0.2,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            scene.tweens.add({
                targets: [adInner],
                alpha: 0.75,
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // ---------- æ·»åŠ æ“ä½œæç¤ºæ–‡å­—ï¼ˆä¼˜åŒ–ç‰ˆï¼Œå®Œå…¨å±…ä¸­ï¼Œå“åº”å¼ï¼‰----------
            const hintBg = scene.add.graphics();
            hintBg.fillStyle(0x000000, 0.5);
            // ä½¿ç”¨æ¸¸æˆç”»å¸ƒçš„ä¸­å¿ƒç‚¹ï¼Œç¡®ä¿åœ¨æ‰€æœ‰è®¾å¤‡ä¸Šéƒ½å±…ä¸­
            const hintWidth = 360;
            const hintHeight = 38;
            const hintX = config.width / 2 - hintWidth / 2;
            const hintY = config.height - 50;
            hintBg.fillRoundedRect(hintX, hintY, hintWidth, hintHeight, 10);
            hintBg.setScrollFactor(0);  // å›ºå®šä½ç½®ï¼Œä¸éšç›¸æœºç§»åŠ¨
            hintBg.setDepth(1000);      // ç¡®ä¿åœ¨æœ€ä¸Šå±‚
            
            const hintText = scene.add.text(
                config.width / 2,  // Xåæ ‡ï¼šç”»å¸ƒå®½åº¦çš„ä¸€åŠ
                config.height - 31, // Yåæ ‡ï¼šè·ç¦»åº•éƒ¨31åƒç´ 
                'ğŸˆ ç‚¹å‡»å±å¹•é£è¡Œ | å¤šäººå®æ—¶åŒæ­¥',
                {
                    fontSize: '16px',
                    fontFamily: 'Inter, sans-serif',
                    color: '#FFFFFF',
                    fontStyle: '600',
                    align: 'center'
                }
            );
            hintText.setOrigin(0.5, 0.5);   // è®¾ç½®æ–‡å­—é”šç‚¹ä¸ºä¸­å¿ƒï¼ˆå…³é”®ï¼ï¼‰
            hintText.setScrollFactor(0);     // å›ºå®šä½ç½®ï¼Œä¸éšç›¸æœºç§»åŠ¨
            hintText.setDepth(1001);         // ç¡®ä¿æ–‡å­—åœ¨èƒŒæ™¯ä¸Šæ–¹
            
            // ---------- åˆå§‹åŒ– Supabase å®æ—¶è¿æ¥ ----------
            initSupabaseRealtime(scene);
            
            // å‘é€åˆå§‹ä½ç½®
            sendPositionUpdate(balloon.x, balloon.y);
        }  // initializeGame å‡½æ•°ç»“æŸ
        
        // ==================== Supabase å®æ—¶åŒæ­¥å‡½æ•° ====================
        
        // å‘é€ä½ç½®æ›´æ–°åˆ° Supabase
        async function sendPositionUpdate(x, y) {
            // å¦‚æœ Supabase å®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œè·³è¿‡
            if (!supabaseClient) {
                console.warn('âš ï¸ Supabase æœªåˆå§‹åŒ–ï¼Œè·³è¿‡ä½ç½®æ›´æ–°');
                return;
            }
            
            try {
                const { error } = await supabaseClient
                    .from('balloon_positions')
                    .upsert({
                        player_id: playerId,
                        player_name: playerName,
                        x: Math.round(x),
                        y: Math.round(y),
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'player_id'
                    });
                
                if (error) {
                    console.error('âŒ å‘é€ä½ç½®å¤±è´¥:', error.message);
                }
            } catch (err) {
                console.error('âŒ å‘é€ä½ç½®å¼‚å¸¸:', err);
            }
        }
        
        // åˆå§‹åŒ– Supabase å®æ—¶ç›‘å¬
        function initSupabaseRealtime(scene) {
            // å¦‚æœ Supabase å®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œè·³è¿‡
            if (!supabaseClient) {
                console.warn('âš ï¸ Supabase æœªåˆå§‹åŒ–ï¼Œæ¸¸æˆå°†ä»¥å•æœºæ¨¡å¼è¿è¡Œ');
                return;
            }
            
            console.log('ğŸ”Œ åˆå§‹åŒ– Supabase Realtime è¿æ¥...');
            
            try {
                // è®¢é˜… balloon_positions è¡¨çš„å˜åŒ–
                const channel = supabaseClient
                    .channel('balloon_positions_channel')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',  // ç›‘å¬æ‰€æœ‰äº‹ä»¶ï¼ˆINSERT, UPDATE, DELETEï¼‰
                            schema: 'public',
                            table: 'balloon_positions'
                        },
                        (payload) => {
                            handleRealtimeUpdate(scene, payload);
                        }
                    )
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            console.log('âœ… Realtime è¿æ¥æˆåŠŸï¼');
                            // åŠ è½½ç°æœ‰ç©å®¶
                            loadExistingPlayers(scene);
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('âŒ Realtime è¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥ Supabase é…ç½®');
                        }
                    });
                
                // å®šæœŸæ¸…ç†ç¦»çº¿ç©å®¶ï¼ˆè¶…è¿‡10ç§’æœªæ›´æ–°ï¼‰
                setInterval(() => {
                    cleanupInactivePlayers(scene);
                }, 5000);
            } catch (error) {
                console.error('âŒ åˆå§‹åŒ– Realtime å¤±è´¥:', error);
            }
        }
        
        // å¤„ç†å®æ—¶æ›´æ–°
        function handleRealtimeUpdate(scene, payload) {
            const { eventType, new: newRecord, old: oldRecord } = payload;
            
            if (eventType === 'INSERT' || eventType === 'UPDATE') {
                const data = newRecord;
                
                // å¿½ç•¥è‡ªå·±çš„æ›´æ–°
                if (data.player_id === playerId) return;
                
                console.log('ğŸ“¡ æ”¶åˆ°å…¶ä»–ç©å®¶ä½ç½®:', data.player_name, data.x, data.y);
                
                // å¦‚æœæ˜¯æ–°ç©å®¶ï¼Œåˆ›å»ºæ°”çƒ
                if (!otherPlayers[data.player_id]) {
                    otherPlayers[data.player_id] = createOtherPlayerBalloon(scene, {
                        x: data.x,
                        y: data.y,
                        name: data.player_name
                    });
                    console.log('ğŸˆ æ–°ç©å®¶åŠ å…¥:', data.player_name);
                } else {
                    // æ›´æ–°ç°æœ‰ç©å®¶çš„ç›®æ ‡ä½ç½®
                    otherPlayers[data.player_id].targetX = data.x;
                    otherPlayers[data.player_id].targetY = data.y;
                }
                
                // æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
                otherPlayers[data.player_id].lastUpdate = Date.now();
            } else if (eventType === 'DELETE') {
                const data = oldRecord;
                if (otherPlayers[data.player_id]) {
                    otherPlayers[data.player_id].container.destroy();
                    delete otherPlayers[data.player_id];
                    console.log('ğŸ‘‹ ç©å®¶ç¦»å¼€:', data.player_name);
                }
            }
        }
        
        // åŠ è½½ç°æœ‰ç©å®¶
        async function loadExistingPlayers(scene) {
            if (!supabaseClient) return;
            
            try {
                // åªåŠ è½½æœ€è¿‘2åˆ†é’Ÿå†…æ´»è·ƒçš„ç©å®¶
                const twoMinutesAgo = new Date(Date.now() - 2 * 60 * 1000).toISOString();
                
                const { data, error } = await supabaseClient
                    .from('balloon_positions')
                    .select('*')
                    .neq('player_id', playerId)
                    .gte('updated_at', twoMinutesAgo)  // åªåŠ è½½2åˆ†é’Ÿå†…æ›´æ–°çš„ç©å®¶
                    .order('updated_at', { ascending: false })
                    .limit(10);  // æœ€å¤šæ˜¾ç¤º10ä¸ªå…¶ä»–ç©å®¶
                
                if (error) {
                    console.error('âŒ åŠ è½½ç°æœ‰ç©å®¶å¤±è´¥:', error.message);
                    return;
                }
                
                if (data && data.length > 0) {
                    console.log('ğŸ‘¥ åŠ è½½æ´»è·ƒç©å®¶:', data.length, 'äºº');
                    data.forEach(player => {
                        if (!otherPlayers[player.player_id]) {
                            otherPlayers[player.player_id] = createOtherPlayerBalloon(scene, {
                                x: player.x,
                                y: player.y,
                                name: player.player_name
                            });
                            otherPlayers[player.player_id].lastUpdate = Date.now();
                        }
                    });
                } else {
                    console.log('ğŸ‘¥ å½“å‰æ²¡æœ‰å…¶ä»–æ´»è·ƒç©å®¶');
                }
                
                // æ¸…ç†æ•°æ®åº“ä¸­è¶…è¿‡5åˆ†é’Ÿçš„æ—§æ•°æ®
                cleanupOldDataInDatabase();
            } catch (err) {
                console.error('âŒ åŠ è½½ç°æœ‰ç©å®¶å¼‚å¸¸:', err);
            }
        }
        
        // æ¸…ç†ä¸æ´»è·ƒçš„ç©å®¶
        async function cleanupInactivePlayers(scene) {
            const now = Date.now();
            const TIMEOUT = 10000;  // 10ç§’è¶…æ—¶
            
            for (const playerId in otherPlayers) {
                if (now - otherPlayers[playerId].lastUpdate > TIMEOUT) {
                    console.log('ğŸ—‘ï¸ æ¸…ç†ä¸æ´»è·ƒç©å®¶:', playerId);
                    otherPlayers[playerId].container.destroy();
                    delete otherPlayers[playerId];
                }
            }
        }
        
        // æ¸…ç†æ•°æ®åº“ä¸­çš„æ—§æ•°æ®
        async function cleanupOldDataInDatabase() {
            if (!supabaseClient) return;
            
            try {
                // åˆ é™¤5åˆ†é’Ÿå‰çš„æ—§æ•°æ®
                const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
                
                const { error } = await supabaseClient
                    .from('balloon_positions')
                    .delete()
                    .lt('updated_at', fiveMinutesAgo);
                
                if (error) {
                    console.error('âŒ æ¸…ç†æ—§æ•°æ®å¤±è´¥:', error.message);
                } else {
                    console.log('ğŸ§¹ å·²æ¸…ç†5åˆ†é’Ÿå‰çš„æ—§æ•°æ®');
                }
            } catch (err) {
                console.error('âŒ æ¸…ç†æ—§æ•°æ®å¼‚å¸¸:', err);
            }
        }

        // ==================== æ›´æ–°åœºæ™¯å‡½æ•°ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰====================
        function update(time, delta) {
            // ---------- æ›´æ–°ç™½äº‘ä½ç½®ï¼ˆç¼“æ…¢æ¨ªå‘ç§»åŠ¨ï¼‰----------
            clouds.forEach(cloud => {
                cloud.graphic.x += cloud.speed;
                
                // å¦‚æœäº‘æœµç§»å‡ºå±å¹•å³ä¾§ï¼Œåˆ™ä»å·¦ä¾§é‡æ–°è¿›å…¥
                if (cloud.graphic.x > config.width + 100) {
                    cloud.graphic.x = -100;
                    cloud.graphic.y = Math.random() * (config.height * 0.4) + 50;
                }
            });

            // ---------- å‘¼å¸æµ®åŠ¨æ•ˆæœ ----------
            // ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›å»ºå¹³æ»‘çš„ä¸Šä¸‹æµ®åŠ¨æ•ˆæœ
            breatheOffset += 0.015;  // æ§åˆ¶å‘¼å¸é€Ÿåº¦ï¼ˆç¨å¾®æ…¢ä¸€ç‚¹æ›´ä¼˜é›…ï¼‰
            const breatheY = Math.sin(breatheOffset) * 8;  // æŒ¯å¹…ä¸º8åƒç´ 
            const breatheScale = 1 + Math.sin(breatheOffset) * 0.03;  // ç¼©æ”¾å˜åŒ– (0.97-1.03)

            // ---------- å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½® ----------
            // è®¡ç®—æ°”çƒå½“å‰ä½ç½®ä¸ç›®æ ‡ä½ç½®çš„è·ç¦»
            const dx = targetX - balloon.x;
            const dy = targetY - balloon.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // å¦‚æœè·ç¦»å¤§äº1åƒç´ ï¼Œåˆ™ç»§ç»­ç§»åŠ¨
            if (distance > 1) {
                // ä½¿ç”¨ç¼“åŠ¨æ•ˆæœï¼šæ¯å¸§ç§»åŠ¨è·ç¦»çš„4%ï¼ˆç¨æ…¢ä¸€ç‚¹æ›´ä¼˜é›…ï¼‰
                const easing = 0.04;
                balloon.x += dx * easing;
                balloon.y += dy * easing;
                
                // å®šæœŸå‘é€ä½ç½®æ›´æ–°ï¼ˆèŠ‚æµï¼‰
                if (time - lastUpdateTime > UPDATE_INTERVAL) {
                    sendPositionUpdate(balloon.x, balloon.y);
                    lastUpdateTime = time;
                }
            }

            // ---------- è®¡ç®—å€¾æ–œè§’åº¦ï¼ˆçµåŠ¨æ•ˆæœï¼‰----------
            // æ ¹æ®ç§»åŠ¨æ–¹å‘è®¡ç®—å€¾æ–œè§’åº¦
            const velocityX = balloon.x - previousX;
            previousX = balloon.x;
            
            // ç›®æ ‡å€¾æ–œè§’åº¦ï¼šå‘å·¦é£æ—¶è´Ÿè§’åº¦ï¼Œå‘å³é£æ—¶æ­£è§’åº¦
            const targetRotation = velocityX * 0.1;  // å€¾æ–œå¹…åº¦ç³»æ•°
            
            // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡è§’åº¦
            const currentRotation = balloon.angle * (Math.PI / 180);  // è½¬æ¢ä¸ºå¼§åº¦
            const targetRad = Phaser.Math.Clamp(targetRotation, -0.15, 0.15);  // é™åˆ¶æœ€å¤§å€¾æ–œè§’åº¦
            
            // ä½¿ç”¨çº¿æ€§æ’å€¼å¹³æ»‘è¿‡æ¸¡
            balloon.angle = Phaser.Math.Linear(balloon.angle, targetRad * (180 / Math.PI), 0.1);

            // ---------- åº”ç”¨å‘¼å¸æ•ˆæœ ----------
            // æ·»åŠ è½»å¾®çš„å‚ç›´æµ®åŠ¨
            const baseY = balloon.y;
            balloon.y = baseY + breatheY * 0.5;

            // åº”ç”¨ç¼©æ”¾æ•ˆæœï¼ˆæ¨¡æ‹Ÿçƒ­æ°”çƒçš„"å‘¼å¸"ï¼‰
            balloon.setScale(breatheScale);
            
            // ---------- ç”Ÿæˆæ¸¸æˆå…ƒç´  ----------
            spawnGameElements(this);
            
            // ---------- æ£€æµ‹ç¢°æ’ ----------
            checkCollisions();
            
            // ---------- æ¸…ç†è¶…å‡ºå±å¹•çš„å…ƒç´  ----------
            coins = coins.filter(coin => {
                if (coin.collected) return false;
                const outOfBounds = coin.x < -50 || coin.x > config.width + 50 || 
                                   coin.y < -50 || coin.y > config.height + 50;
                if (outOfBounds && coin.graphic) {
                    coin.graphic.destroy();
                }
                return !outOfBounds;
            });
            
            obstacles = obstacles.filter(obstacle => {
                const outOfBounds = obstacle.x < -100 || obstacle.x > config.width + 100;
                if (outOfBounds && obstacle.graphic) {
                    obstacle.graphic.destroy();
                }
                return !outOfBounds;
            });
            
            // ---------- æ›´æ–°å…¶ä»–ç©å®¶çš„æ°”çƒ ----------
            for (const playerId in otherPlayers) {
                const player = otherPlayers[playerId];
                const container = player.container;
                
                // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                const pdx = player.targetX - container.x;
                const pdy = player.targetY - container.y;
                const pdistance = Math.sqrt(pdx * pdx + pdy * pdy);
                
                if (pdistance > 1) {
                    const easing = 0.04;
                    container.x += pdx * easing;
                    container.y += pdy * easing;
                    
                    // è®¡ç®—å€¾æ–œè§’åº¦
                    const pVelocityX = pdx * easing;
                    const pTargetRotation = pVelocityX * 0.1;
                    const pTargetRad = Phaser.Math.Clamp(pTargetRotation, -0.15, 0.15);
                    container.angle = Phaser.Math.Linear(container.angle, pTargetRad * (180 / Math.PI), 0.1);
                }
                
                // æ·»åŠ å‘¼å¸æ•ˆæœ
                container.y += breatheY * 0.3;
                container.setScale(breatheScale * 0.95);  // å…¶ä»–ç©å®¶ç¨å¾®å°ä¸€ç‚¹
            }
        }
        
        // ==================== é¡µé¢å…³é—­æ—¶æ¸…ç† ====================
        window.addEventListener('beforeunload', async () => {
            // åˆ é™¤è‡ªå·±çš„ä½ç½®è®°å½•
            if (!supabaseClient) return;
            
            try {
                await supabaseClient
                    .from('balloon_positions')
                    .delete()
                    .eq('player_id', playerId);
            } catch (err) {
                console.error('æ¸…ç†ä½ç½®è®°å½•å¤±è´¥:', err);
            }
        });
    </script>
</body>
</html>